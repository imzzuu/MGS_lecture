<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Slider</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      li {
        list-style: none;
      }
      .kind_wrap {
        border: 2px solid black;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
        position: relative;
      }
      .kind_wrap > .kind_slider {
        overflow: hidden;
      }
      .kind_wrap > .kind_slider .slider {
        position: relative;
        /* left: 0;
        transition: 0.5s ease-in-out; */
      }
      .kind_wrap > .kind_slider .slider li {
        float: left;
      }
      .kind_wrap > .kind_slider img {
        vertical-align: top;
      }
      .kind_wrap .arrow > a.prev {
        position: absolute;
        left: -50px;
        top: 100px;
      }
      .kind_wrap .arrow > a.next {
        position: absolute;
        right: -50px;
        top: 100px;
      }
    </style>
  </head>
  <body>
    <div class="kind_wrap">
      <div class="kind_slider">
        <ul class="slider">
          <li>
            <img src="https://via.placeholder.com/800x200.png?text=1" alt="" />
          </li>
          <li>
            <img src="https://via.placeholder.com/800x200.png?text=2" alt="" />
          </li>
          <li>
            <img src="https://via.placeholder.com/800x200.png?text=3" alt="" />
          </li>
        </ul>
      </div>
      <div class="arrow">
        <a href="" class="prev">이전</a>
        <a href="" class="next">다음</a>
      </div>
    </div>

    <script>
      // 모든 html 요소들이 모두 로드가 된 후에 함수 안의 코드를 실행한다. => 비동기 컨트롤
      window.onload = function () {
        /* 노드 준비 */
        const kindWrap = document.querySelector(".kind_wrap");
        const slider = kindWrap.querySelector(".slider");
        //   querySelectorAll 은 배열을 반환(실제 배열은 아님)
        const slideLis = slider.querySelectorAll("li");
        const moveBtn = kindWrap.querySelector(".arrow");
        const cloneA = slideLis[0].cloneNode(true);
        const cloneC = slideLis[slideLis.length - 1].cloneNode(true);
        // 두 번째 인자 앞에 첫 번째 인자를 넣어라
        slider.insertBefore(cloneC, slideLis[0]);
        slider.appendChild(cloneA);
        // 만들고 나서 다시 한번 li의 갯수를 세야함 => slideCloneLis
        // (이 밑으로 가져오면 슬라이더를 통해 차일드를 만들 수 없기 때문에)

        /* 주요 변수 초기화*/
        let moveDist = 0;
        let currentNum = 1;
        const speedTime = 0.5;

        /* ul의 넓이 계산 및 CSSOM 셋업 */
        const slideCloneLis = slider.querySelectorAll("li");
        const liWidth = slideLis[0].clientWidth;
        const sliderWidth = liWidth * slideCloneLis.length;
        slider.style.width = `${sliderWidth}px`;
        moveDist = -liWidth;
        slider.style.left = `${-liWidth}px`;

        // function sample (){
        //     return moveDist = currentNum++
        // }
        // 이건 콜스텍 연결이 끊기면 사라집
        // 함수가 끝나는 시점에 외부 참조가 없어서 가비지컬렉션에 의해 수거대상이 되기 때문

        /* 이벤트 리스너 */
        // 외부 참조(객체 메모리 참조)를 하기 때문에 콜스텍이 없어져도 데이터가 사라지지 않음

        moveBtn.addEventListener("click", (e) => {
          // btn 아니고 a 태그라서 이벤트가 생기면 새로고침됨 그걸 막아주는 것
          e.preventDefault(); // 이벤트 객체의 메서드
          // btn 에 이벤트 버블링을 통해서 e.target으로 컨트롤하기

          const move = (n) => {
            currentNum += -1 * n;
            moveDist += liWidth * n;
            slider.style.left = `${moveDist}px`;
            slider.style.transition = `${speedTime}s ease`;
          };

          if (e.target.className === "next") {
            // 다음이 눌렸을 때
            move(-1);
            if (currentNum === slideCloneLis.length - 1) {
              // 마지막이면
              setTimeout(() => {
                slider.style.transition = "none"; // 애니메이션 끄고
                moveDist = -liWidth; // 진짜 A 값으로 만들고
                slider.style.left = `${-liWidth}px`; // 진짜 A를 보여줌
                currentNum = 1;
              }, speedTime);
            }
            console.log(currentNum, moveDist);
          } else {
            move(1);
            if (currentNum === 0) {
            }
          }

          //   // 페이크 전
          //   //   let moveDist = 0;
          //   //     let currentNum = 0;

          //   if (e.target.className === "next") {
          //     // 다음이 눌렸을 때
          //     if (currentNum === slideLis.length - 1) return;
          //     // 무한 루프
          //     //   currentNum = 0;
          //     //   moveDist = 0;
          //     //   slider.style.left = `${moveDist}px`;
          //     move(-1);
          //     // 코드 줄이기 전
          //     // currentNum++;
          //     // moveDist += -liWidth;
          //     // slider.style.left = `${moveDist}px`;

          //     console.log(currentNum, moveDist);
          //   } else {
          //     if (currentNum === 0) return;
          //     // 무한 루프
          //     // currentNum = slideLis.length - 1;
          //     // moveDist = -(liWidth * currentNum);
          //     // slider.style.left = `${moveDist}px`;
          //     move(1);
          //     //  코드 줄이기 전
          //     // currentNum--;
          //     // moveDist += liWidth;
          //     // slider.style.left = `${moveDist}px`;
          //     // console.log(currentNum, moveDist);
          //   }
        });
      };
    </script>
  </body>
</html>
